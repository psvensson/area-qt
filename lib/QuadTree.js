// Generated by CoffeeScript 1.9.3
(function() {
  var QuadTree, asciitree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  asciitree = require('ascii-tree');

  QuadTree = (function() {
    function QuadTree(bounds, maxObjectsPerLevel, parent, idProperty) {
      this.bounds = bounds;
      this.maxObjectsPerLevel = maxObjectsPerLevel;
      this.parent = parent;
      this.idProperty = idProperty != null ? idProperty : 'id';
      this._dumpTree = bind(this._dumpTree, this);
      this._getMidPoints = bind(this._getMidPoints, this);
      this._getIndexFor = bind(this._getIndexFor, this);
      this._isWithin = bind(this._isWithin, this);
      this.getCollissionsFor = bind(this.getCollissionsFor, this);
      this.remove = bind(this.remove, this);
      this.retrieve = bind(this.retrieve, this);
      this.insert = bind(this.insert, this);
      this.subTrees = [];
      this.objects = [];
    }

    QuadTree.prototype.insert = function(rect) {
      var i, ind, index, j, len, newObjects, o, ref, subtree, tree;
      if (rect.x < this.bounds.x || rect.x > this.bounds.x + this.bounds.width || rect.y < this.bounds.y || rect.y > this.bounds.y + this.bounds.height) {
        console.log('area-quadtree insert failed for ' + rect.x + ',' + rect.y + ' tree ' + this.bounds.x + ',' + this.bounds.y + ' - ' + this.bounds.width + ',' + this.bounds.height + ' objects.length is ' + this.objects.length + ' maxobjects are ' + this.maxObjectsPerLevel);
        xyzzy();
      }
      if (this.objects.length > this.maxObjectsPerLevel) {
        this.subTrees.push(new QuadTree({
          x: this.bounds.x + this.bounds.width / 2,
          y: this.bounds.y,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }, this.maxObjectsPerLevel, this));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x,
          y: this.bounds.y,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }, this.maxObjectsPerLevel, this));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x,
          y: this.bounds.y + this.bounds.height / 2,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }, this.maxObjectsPerLevel, this));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x + this.bounds.width / 2,
          y: this.bounds.y + this.bounds.height / 2,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }, this.maxObjectsPerLevel, this));
        newObjects = [];
        ref = this.objects;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          o = ref[i];
          index = this._getIndexFor(o);
          if (index > -1) {
            subtree = this.subTrees[index];
            subtree.insert(o);
          } else {
            newObjects.push(o);
          }
        }
        this.objects = newObjects;
      }
      ind = this._getIndexFor(rect);
      if (this.subTrees.length > 0 && ind > -1) {
        tree = this.subTrees[ind];
        return tree.insert(rect);
      } else {
        return this.objects.push(rect);
      }
    };

    QuadTree.prototype.retrieve = function(_rect) {
      var index, rect, rv;
      rect = {
        x: _rect.x,
        y: _rect.y,
        width: _rect.width || 1,
        height: _rect.height || 1
      };
      rv = [];
      index = this._getIndexFor(rect);
      if (this.subTrees.length > 0 && index > -1) {
        this.subTrees[index].retrieve(rect);
      } else {
        this.objects.forEach(function(object) {
          if (object.x === rect.x && object.y === rect.y && object.width === rect.width && object.height === rect.height) {
            return rv.push(object);
          }
        });
      }
      return rv;
    };

    QuadTree.prototype.remove = function(rect, id) {
      var index, newObjects;
      index = this._getIndexFor(rect);
      if (this.subTrees.length > 0 && index > -1) {
        this.subTrees[index].remove(rect);
      } else {
        newObjects = [];
        this.objects.forEach(function(o) {
          if (id) {
            if (o[this.idProperty] === id) {
              return newObjects.push(o);
            }
          } else {
            if (o.x !== rect.x || o.y !== rect.y || o.width !== rect.width || o.height !== rect.height) {
              return newObjects.push(o);
            }
          }
        });
        this.objects = newObjects;
      }
      if (this.objects.length < this.maxObjectsPerLevel && this.parent) {
        this.parent.subTrees.forEach((function(_this) {
          return function(st) {
            return st.objects.forEach(function(o) {
              return _this.parent.objects.push(o);
            });
          };
        })(this));
        return this.parent.subTrees = [];
      }
    };

    QuadTree.prototype.getCollissionsFor = function(rect, rv) {
      var index;
      rv = rv || [];
      this.objects.forEach((function(_this) {
        return function(o) {
          if ((_this._isWithin(rect, o) || _this._isWithin(o, rect)) && o !== rect) {
            return rv.push(o);
          }
        };
      })(this));
      index = this._getIndexFor(rect);
      if (index > -1) {
        return this.subTrees[index].getCollissionsFor(rect, rv);
      } else {
        return rv;
      }
    };

    QuadTree.prototype._isWithin = function(r1, r2) {
      return r1.x <= r2.x + r2.width && r1.x >= r2.x && r1.y <= r2.y + r2.height && r1.y >= r2.y;
    };

    QuadTree.prototype._getIndexFor = function(rect) {
      var bottom, index, left, midx, midy, ref, right, top;
      index = -1;
      ref = this._getMidPoints(), midx = ref[0], midy = ref[1];
      top = rect.y < midy && (rect.y + rect.height) < midy;
      bottom = rect.y > midy && (rect.y + rect.height) < this.bounds.y + this.bounds.height;
      left = rect.x < midx && (rect.x + rect.width) < midx;
      right = rect.x > midx && (rect.x + rect.width) < this.bounds.x + this.bounds.width;
      if (top && right) {
        index = 0;
      }
      if (top && left) {
        index = 1;
      }
      if (bottom && left) {
        index = 2;
      }
      if (bottom && right) {
        index = 3;
      }
      return index;
    };

    QuadTree.prototype._getMidPoints = function() {
      return [this.bounds.x + this.bounds.width / 2, this.bounds.y + this.bounds.height / 2];
    };

    QuadTree.prototype._dumpTree = function(level) {};

    return QuadTree;

  })();

  module.exports = QuadTree;

}).call(this);

//# sourceMappingURL=QuadTree.js.map
