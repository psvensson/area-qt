// Generated by CoffeeScript 1.9.3
(function() {
  var QuadTree,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  QuadTree = (function() {
    function QuadTree(bounds, maxObjectsPerLevel) {
      this.bounds = bounds;
      this.maxObjectsPerLevel = maxObjectsPerLevel;
      this._doInsert = bind(this._doInsert, this);
      this._getMidPoints = bind(this._getMidPoints, this);
      this._getIndexFor = bind(this._getIndexFor, this);
      this.getCollissionsFor = bind(this.getCollissionsFor, this);
      this.remove = bind(this.remove, this);
      this.retrieve = bind(this.retrieve, this);
      this.insert = bind(this.insert, this);
      this.subTrees = [];
      this.objects = [];
    }

    QuadTree.prototype.insert = function(rect) {
      var index;
      if (this.subTrees.length > 0) {
        index = this._getIndexFor(rect);
        if (index > -1) {
          return this.subTrees[index].insert(rect);
        } else {
          return this._doInsert(rect);
        }
      } else {
        return this._doInsert(rect);
      }
    };

    QuadTree.prototype.retrieve = function(rect) {
      var index, rv;
      rv = void 0;
      index = this._getIndexFor(rect);
      if (this.subTrees.length > 0 && index > -1) {
        rv = this.subTrees[index].retrieve(rect);
      } else {
        this.objects.forEach(function(object) {
          if (object.x === rect.x && object.y === rect.y && object.width === rect.width && object.height === rect.height) {
            return rv = object;
          }
        });
      }
      return rv;
    };

    QuadTree.prototype.remove = function(rect) {};

    QuadTree.prototype.getCollissionsFor = function(rect) {};

    QuadTree.prototype._getIndexFor = function(rect) {
      var bottomQuadrant, horizontalMidpoint, index, ref, topQuadrant, verticalMidpoint;
      index = -1;
      ref = this._getMidPoints(), horizontalMidpoint = ref[0], verticalMidpoint = ref[1];
      topQuadrant = rect.y < horizontalMidpoint && rect.y + rect.height < horizontalMidpoint;
      bottomQuadrant = rect.y > horizontalMidpoint;
      if (rect.x < verticalMidpoint && rect.x + rect.width < verticalMidpoint) {
        if (topQuadrant) {
          index = 1;
        } else if (bottomQuadrant) {
          index = 2;
        }
      } else if (rect.x > verticalMidpoint) {
        if (topQuadrant) {
          index = 0;
        } else if (bottomQuadrant) {
          index = 3;
        }
      }
      return index;
    };

    QuadTree.prototype._getMidPoints = function() {
      return [this.bounds.x + this.bounds.width / 2, this.bounds.y + this.bounds.height / 2];
    };

    QuadTree.prototype._doInsert = function(rect) {
      var horizontalMidpoint, i, index, j, len, newObjects, o, ref, ref1, subtree, verticalMidpoint;
      this.objects.push(rect);
      if (this.objects.length > this.maxObjectsPerLevel) {
        ref = this._getMidPoints(), horizontalMidpoint = ref[0], verticalMidpoint = ref[1];
        this.subTrees.push(new QuadTree({
          x: this.bounds.x + horizontalMidpoint,
          y: this.bounds.y,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x,
          y: this.bounds.y,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x,
          y: this.bounds.y + verticalMidpoint,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }));
        this.subTrees.push(new QuadTree({
          x: this.bounds.x + horizontalMidpoint,
          y: this.bounds.y + verticalMidpoint,
          width: this.bounds.width / 2,
          height: this.bounds.height / 2
        }));
        newObjects = [];
        ref1 = this.objects;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          o = ref1[i];
          index = this._getIndexFor(o);
          if (index > -1) {
            subtree = this.subTrees[index];
            subtree.insert(o);
          } else {
            newObjects.push(o);
          }
        }
        return this.objects = newObjects;
      }
    };

    return QuadTree;

  })();

  module.exports = QuadTree;

}).call(this);

//# sourceMappingURL=QuadTree.js.map
